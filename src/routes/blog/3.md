---
title: Post Three
date: '2024-1-4'
---

## Evildoer

### Variable Names are Irrelevant

The compiler doesn't need to know the name of a variable
Using natural numbers can help the compiler find where a variable is on the stack
(Ex: 1 let expression away from the current binding)

Lexical address: the distance in memory between a binding and our current location in code

Just add values of expressions into a list (environment)

## Stack in x86

The stack is just memory allocated to your program
Its address is held in the _rsp_ register
Stack grows downward towards lower memory addresses

Instructions that affect the stack
Push reg - puts value into register and pushes to the top of the stack
Pop reg - takes value at the top of the stack and puts it into the register
Add/Sub _rsp_ n - adds to the stack pointer
Call label
Ret
Offset _rsp_ i - get value at offset i on the stack

Remember 64 bits is 8 bytes
So offsets are usually in steps of 8 bytes

Subtract 8 from _rsp_ to make room for values without having to know what those values are (like Push)

At compile time, we are going to have an environment containing variables and their lexical addresses
We can get the values of these addresses at runtime

### Compiling Variables

Lookup the index of a variable in the environment
Get the value of the variable by its offset from the stack pointer (the index)  
Move the value of that variable into _rax_

### Compiling Lets

```scheme
(define (compile-let x e1 e2 c) ;; ...)
```

Compile the first expression _e1_
Push _rax_ to the stack
Compile the second expression _e2_ with the new variable _x_ in the environment _c_

Length of the environment - the number of values on the stack at that time

> [!NOTE] Q4 on Midterm 1
> Check if subexpressions, not predicates, are safe
> Prim1 p e → just check e, since the way we compile p does not involve the interpreter

## Fraud

### Binary Primitives

```scheme
;; function header:
(define (compile-+ e0 e1 c))

;; transform this statement into a let expression
(+ e0 e1 c) -> (let ((x e0)) (+ x e1))

;; function body:
;; generate a new variable, so nothing in e1 overwrites it
(let ((x gensym)))
	(seq
	;; compile e0
	;; push it to the stack
	(compile-e e0 c)
	(Push 'rax)
	;; then push a filler value to the environment so the location of
	;; e0 is not lost, #f since we know no variable is equal to it
	(compile-e e1 (cons #f c))
	;; evaluate e1
	;; pop e0 from stack
	;; add to 'rax
	(Pop 'r8)
	(Add 'rax 'r8)))
```

Transform any binary operation into a let expression as we have done in the above example

```scheme
‘(z y #f #f x #f q p)
;; the above environment could be visualized like so
(let ((p ...))
	(let ((q ...))
	 (+ ... (let ((x ...))
	 (= ... (> ... (let ((y ...))
	 (let ((z ...))
	 ;; HERE)))))))
```

### Stack Alignment

Stack alignment matters when we use the Call instruction or call one program from another
Stack is 8-byte = 64-bit aligned, divisible by 8, ends in \#b000, and must align to 16-bytes to call
This is because everything we have \[pushed to/popped from\] the stack has been 8-bytes long (so far)

We use a pad stack function to prepare the stack for operations

## Hustle

Using the heap for data structures like box and cons

### Lists

We are implementing box and cons structures
Registers can hold 64-bit integers, not large enough for arbitrarily long lists

**So we are going to use pointers**
64 bit address pointing to the first word of a list
A pair is allocated as two words in memory

## Hoax

Vectors and strings
Think of vectors as arrays - fixed size collections of values
Vectors are also mutable structures
Recall the three least significant bits are being used for pointer types

Box → 0 0 1
Cons → 0 1 0
Vector → 0 1 1
String → 1 0 0

We can erase the tags when we want the original pointer values
We are doing this with the knowledge that every pointer ends in 0 0 0
If the values are not pointers, and represent some other type, we can get the original value by shifting the bits to the right by 3
Constructors allocate and initialize values
Projections dereference values

Every address points to a byte (8 bits) of memory
We are going to store things in 64 bit chunks so to go from one value to another, we have to add 8 bytes, or 64 bits
This alignment means that every 64 bit index ends with \#b000

The register rbx holds the address of the next free location in memory
To allocate memory, increment the value of rbx by a multiple of 8
To initialize memory, write a value to the memory in that location

We need to store vector size on the heap along with the values in the vector
Storing boxes or cons on the stack would require a minimum of 128 bits for a pair
Cannot represent all of our data with these fixed bits, so we allocate memory on the heap and store a pointer to that location in the heap

How do we represent strings?
Sized homogenous arrays
More specifically…
Strings are codepoint arrays that carry their size
Every access performs bounds checking
Immutable

## Iniquity

### Caller vs Callee

The caller must

- Pass arguments
- Caller must provide a return address for the callee so it can handle the output

The callee must

- Provide an output

We need to care about the argument eval. order
Racket evaluates arguments left to right
OCaml evaluates arguments right to left
Generally avoid programs that depend on evaluation order
